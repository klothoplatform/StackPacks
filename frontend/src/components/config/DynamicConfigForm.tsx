import { trackError } from "../../pages/store/ErrorStore";
import type { FC } from "react";
import React from "react";

import { ErrorBoundary } from "react-error-boundary";
import { FallbackRenderer } from "../FallbackRenderer";
import { UIError } from "../../shared/errors";
import type { Property } from "../../shared/configuration-properties.ts";
import { ConfigSection } from "./ConfigSection.tsx";
import { ConfigGroup } from "./ConfigGroup.tsx";
import { CollapsibleSection } from "../CollapsibleSection.tsx";

const importantPropertyPredicate = (property: Property) =>
  property.defaultValue === undefined &&
  !property.autoGenerated &&
  property.required;

export interface DynamicSection {
  icon?: React.ReactNode;
  title: string;
  prefix?: string;
  propertyMap: Map<string, Property[]>;
  defaultOpened?: boolean;
  flat?: boolean;
  collapseOptionalFields?: boolean;
}

interface DynamicConfigFormProps {
  sections?: DynamicSection[];
}

export const DynamicConfigForm: FC<DynamicConfigFormProps> = ({ sections }) => {
  return (
    <ErrorBoundary
      onError={(error, info) =>
        trackError(
          new UIError({
            message: "uncaught error in ConfigForm",
            errorId: "ConfigForm:ErrorBoundary",
            cause: error,
            data: { info },
          }),
        )
      }
      fallbackRender={FallbackRenderer}
    >
      <div className="size-fit min-h-0 w-full pb-2 [&>*:not(:last-child)]:mb-2">
        {sections?.map((section, index) => {
          if (section.flat) {
            return [...section.propertyMap.entries()].map(
              ([stackPackId, properties], index) => {
                if (properties.length === 0) {
                  return null;
                }
                return (
                  <ConfigGroup
                    key={index}
                    prefix={`${section.prefix ? section.prefix + "#" : ""}${stackPackId}`}
                    fields={properties}
                  />
                );
              },
            );
          }

          const configGroups = [];
          for (const [stackPackId, properties] of section.propertyMap) {
            if (properties.length === 0) {
              continue;
            }

            if (!section.collapseOptionalFields) {
              configGroups.push(
                <ConfigGroup
                  key={stackPackId}
                  prefix={stackPackId}
                  fields={properties}
                />,
              );
              continue;
            }

            const importantProperties = properties.filter(
              importantPropertyPredicate,
            );
            const additionalProperties = properties.filter(
              (property) => !importantPropertyPredicate(property),
            );
            configGroups.push(
              <ConfigGroup
                key={stackPackId}
                prefix={stackPackId}
                fields={importantProperties}
              />,
            );

            configGroups.push(
              <CollapsibleSection
                renderCollapsed
                trigger={({ isOpen }) => (
                  <span className="pl-1 text-sm text-blue-600 dark:text-blue-400">
                    {isOpen ? "Hide" : "Show"} additional properties
                  </span>
                )}
                key={`${stackPackId}-additional`}
                collapsed={true}
                placement={"top-left"}
              >
                <ConfigGroup
                  prefix={stackPackId}
                  fields={additionalProperties}
                />
              </CollapsibleSection>,
            );
          }

          return (
            <ConfigSection
              key={index}
              id={section.title}
              icon={section.icon}
              title={section.title}
              removable={false}
              defaultOpened={section.defaultOpened ?? true}
            >
              {configGroups}
            </ConfigSection>
          );
        })}
      </div>
    </ErrorBoundary>
  );
};
