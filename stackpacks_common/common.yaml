network:
  always_inject:
    - aws:region:region
    - aws:availability_zone:region:az1
    - aws:availability_zone:region:az2
  resources:
    aws:region:region:
    aws:availability_zone:region:az1:
      Region: aws:region:region
      Index: 0
    aws:availability_zone:region:az2:
      Region: aws:region:region
      Index: 1
    aws:vpc:stackpacks-vpc:
    aws:subnet:stackpacks-private-subnet-1:
      Type: private
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az1
    aws:subnet:stackpacks-private-subnet-2:
      Type: private
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az2
    aws:subnet:stackpacks-public-subnet-1:
      Type: public
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az1
    aws:subnet:stackpacks-public-subnet-2:
      Type: public
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az2
  edges:
    # We need to connect the subnets to the region since normally they autogenerate one and ecs requires a downstream region for logs
    # Because the engine wont modify anything about existing resources without explicit command this is our workaround
    aws:subnet:stackpacks-public-subnet-1 -> aws:region:region:
    aws:subnet:stackpacks-public-subnet-2 -> aws:region:region:
    aws:subnet:stackpacks-private-subnet-1 -> aws:region:region:
    aws:subnet:stackpacks-private-subnet-2 -> aws:region:region:

ecs:
  depends_on:
    - network
  resources:
    aws:ecs_cluster:stackpacks-ecs-cluster:
    aws:ec2_launch_template:stackpacks-ecs-launch-template:
      LaunchTemplateData:
        InstanceType: t3.medium
    aws:auto_scaling_group:stackpacks-asg:
      MinSize: 1
      MaxSize: 3
    aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider:
    aws:ecs_capacity_provider:stackpacks-capacity-provider:
  edges:
    aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider -> aws:ecs_cluster:stackpacks-ecs-cluster:
    aws:ecs_capacity_provider:stackpacks-capacity-provider -> aws:auto_scaling_group:stackpacks-asg:
    aws:ecs_capacity_provider:stackpacks-capacity-provider -> aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider:
    aws:auto_scaling_group:stackpacks-asg -> aws:ec2_launch_template:stackpacks-ecs-launch-template:

health_monitor:
  always_inject:
    - aws:cloudwatch_alarm -> aws:sns_topic:alarm_actions_topic
  never_inject:
    - aws:ecr_image:health_monitor
    - aws:lambda_function:health_monitor
  resources:
    aws:ecr_image:health_monitor:
      BaseImage: public.ecr.aws/lambda/python:3.12
      Dockerfile: health_monitor/Dockerfile
      Context: health_monitor
    aws:sns_topic:alarm_actions_topic:
    aws:lambda_function:health_monitor:
      Image: aws:ecr_image:health_monitor
      EnvironmentVariables:
        # TODO: Find a way to know how to set constraints smarter or fix the engine
        constraint_top_level:
        PACK_ID: ${PackId}
        HEALTH_ENDPOINT_URL: ${HealthEndpointUrl}
  edges:
    aws:sns_topic:alarm_actions_topic -> aws:lambda_function:health_monitor:
    aws:cloudwatch_alarm -> aws:sns_topic:alarm_actions_topic:
  files: 
    health_monitor/main.py:
    health_monitor/requirements.txt:
    health_monitor/Dockerfile:

  configuration:
    PackId: 
      name: PackId
      description: The pack id that this health monitor is monitoring
      type: string
    HealthEndpointUrl: 
      name: HealthEndpointUrl
      description: The health endpoint url that this health monitor is monitoring
      type: string