network:
  always_inject:
    - aws:region:region
    - aws:availability_zone:region:az1
    - aws:availability_zone:region:az2
  resources:
    aws:region:region:
    aws:availability_zone:region:az1:
      Region: aws:region:region
      Index: 0
    aws:availability_zone:region:az2:
      Region: aws:region:region
      Index: 1
    aws:vpc:stackpacks-vpc:
    aws:subnet:stackpacks-private-subnet-1:
      Type: private
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az1
    aws:subnet:stackpacks-private-subnet-2:
      Type: private
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az2
    aws:subnet:stackpacks-public-subnet-1:
      Type: public
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az1
    aws:subnet:stackpacks-public-subnet-2:
      Type: public
      Vpc: aws:vpc:stackpacks-vpc
      AvailabilityZone: aws:availability_zone:region:az2
  edges:
    # We need to connect the subnets to the region since normally they autogenerate one and ecs requires a downstream region for logs
    # Because the engine wont modify anything about existing resources without explicit command this is our workaround
    aws:subnet:stackpacks-public-subnet-1 -> aws:region:region:
    aws:subnet:stackpacks-public-subnet-2 -> aws:region:region:
    aws:subnet:stackpacks-private-subnet-1 -> aws:region:region:
    aws:subnet:stackpacks-private-subnet-2 -> aws:region:region:

ecs:
  depends_on:
    - network
  resources:
    aws:ecs_cluster:stackpacks-ecs-cluster:
    aws:ec2_launch_template:stackpacks-ecs-launch-template:
      LaunchTemplateData:
        InstanceType: t3.medium
    aws:auto_scaling_group:stackpacks-asg:
      MinSize: 1
      MaxSize: 3
    aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider:
    aws:ecs_capacity_provider:stackpacks-capacity-provider:
  edges:
    aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider -> aws:ecs_cluster:stackpacks-ecs-cluster:
    aws:ecs_capacity_provider:stackpacks-capacity-provider -> aws:auto_scaling_group:stackpacks-asg:
    aws:ecs_capacity_provider:stackpacks-capacity-provider -> aws:ecs_cluster_capacity_provider:stackpacks-cluster-capacity-provider:
    aws:auto_scaling_group:stackpacks-asg -> aws:ec2_launch_template:stackpacks-ecs-launch-template:

health_monitor:
  always_inject:
    - aws:cloudwatch_alarm -> aws:sns_topic:alarm_actions_topic
  never_inject:
    - aws:ecr_image:health_monitor
    - aws:lambda_function:health_monitor
  resources:
    aws:ecr_image:health_monitor:
      BaseImage: public.ecr.aws/lambda/python:3.12
      Dockerfile: health_monitor/Dockerfile
      Context: health_monitor
    aws:sns_topic:alarm_actions_topic:
    aws:lambda_function:health_monitor:
      Image: aws:ecr_image:health_monitor
      EnvironmentVariables:
        # TODO: Find a way to know how to set constraints smarter or fix the engine
        constraint_top_level:
        PACK_ID: ${PackId}
        HEALTH_ENDPOINT_URL: ${HealthEndpointUrl}
  edges:
    aws:sns_topic:alarm_actions_topic -> aws:lambda_function:health_monitor:
    aws:cloudwatch_alarm -> aws:sns_topic:alarm_actions_topic:
  files: 
    health_monitor/main.py:
    health_monitor/requirements.txt:
    health_monitor/Dockerfile:

  configuration:
    PackId: 
      name: PackId
      description: The pack id that this health monitor is monitoring
      type: string
    HealthEndpointUrl: 
      name: HealthEndpointUrl
      description: The health endpoint url that this health monitor is monitoring
      type: string

rds:
  always_inject:
    - aws:rds_instance:stacksnap-db
  never_inject:
    - aws:ecr_image:database_manager
    - aws:lambda_function:database_manager
  resources:
    aws:rds_instance:stacksnap-db:
      AllocatedStorage: 100
    aws:ecr_image:database_manager:
      BaseImage: public.ecr.aws/lambda/python:3.12
      Dockerfile: database_manager/Dockerfile
      Context: database_manager
    aws:lambda_function:database_manager:
      Image: aws:ecr_image:database_manager
      Tags:
        STACKSNAP_FUNCTION: DATABASE_MANAGER
      EnvironmentVariables:
        # TODO: Find a way to know how to set constraints smarter or fix the engine
        constraint_top_level:
        DB_HOST: aws:rds_instance:stacksnap-db#Host
        DB_USER: aws:rds_instance:stacksnap-db#Username
        DB_PASSWORD: aws:rds_instance:stacksnap-db#Password
  edges:
    aws:lambda_function:database_manager -> aws:rds_instance:stacksnap-db:
  files: 
    database_manager/main.py:
    database_manager/requirements.txt:
    database_manager/Dockerfile:

  configuration:
    DBUsername:
      name: Database Username
      description: The username to use for the metabase database
      type: string
      default: masterdbuser
      pulumi_key: klo:stacksnap-db-username
      validation:
        minLength: 1
        maxLength: 63

    DBPassword:
      name: Database Password
      description: The password to use for the metabase database
      type: string
      default: masterdbpassword
      pulumi_key: klo:stacksnap-db-password
      secret: true
      validation:
        minLength: 8
        maxLength: 128

  additional_policy:
    Version: "2012-10-17"
    Statement:
      - Effect: "Allow"
        Action:
          - "lambda:invokeFunction"
        Resource: "*"
        Condition:
          StringEquals:
            aws:ResourceTag/STACKSNAP_FUNCTION: "DATABASE_MANAGER"
